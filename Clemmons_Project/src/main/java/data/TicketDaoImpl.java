package data;

import entity.Employee;
import entity.Ticket;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

// Here, we are going to implement some methods that interact with the database:
public class TicketDaoImpl implements TicketDao{

    Connection connection;

    // constructor initialize the connection based on our connection factory:
    public TicketDaoImpl() {
        connection = ConnectionFactory.getConnection();
    }

    // take in a pet object and return the pet with the updated id
    @Override
    public Ticket insert(Ticket ticket) {
        System.out.println(ticket.toString());
        System.out.println("Now we're in the DAO trying to pass in pet object to the database");
        // As the code is right now, we insert the same pet over and over again
        // String sql = "insert into pet (id, name, species, food) values (default, 'Ashes', 'cat', 'tuna');";

        // This is dangerous, SQLInjection, if we use string concatenation, bad people can sneak in very dangerous commands:
        // very unpredicatable
//        String sql = "insert into pet(id, name, species, food) values (default, " + pet.getName() + "," +  pet.getFood();
//        System.out.println(sql);

        // wherever we want to include a value, we leave it as a question mark for now:
        String sql = "insert into tickets(id, owner_id, name, description, amount, status) values (default, ?, ?, ?, ?, ?);";

        try {
            // here, we pass in a flag that tells the program that we want to return the generated id:
            PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            // taking our statement and setting up the values based on where we put the ?

            preparedStatement.setInt(1, ticket.getAmount());
            preparedStatement.setString(2, ticket.getName());
            preparedStatement.setString(3, ticket.getDescription());
            preparedStatement.setInt(4, ticket.getAmount());
            preparedStatement.setBoolean(5, ticket.getStatus());
            System.out.println(preparedStatement.toString());

            // we've set up the string but we haven't executed the statement
            // we use the executeUpdate method whenever we do DML operations (insert, update, delete):
            // going to return the number of records that were updated (or in this case inserted)
            int count = preparedStatement.executeUpdate();
            // we've successfully inserted a single record
            if(count == 1) {
                System.out.println("Ticket added successfully.");
                // Now, we have to get the id that was generated by the database
                // whenever we get a return value from the database, we store it in a result set:
                ResultSet resultSet = preparedStatement.getGeneratedKeys();
                // right when we get our result set, it actually points to nothing, so we increment it:
                resultSet.next();
                /**
                 * Generated id might look like this:
                 * -------
                 * |  1  |
                 * -------
                 */
                // because result sets in general can return multiple values, we have to specify which one we want
                // but in this case, there's only one value, so we take the first one
                int generatedId = resultSet.getInt(1);
                // set the id to the original object:
                ticket.setId(generatedId);
            }
            else {
                System.out.println("Something went wrong with the insert!");
            }
        } catch (SQLException e) {
            e.printStackTrace();
            System.out.println("Something went wrong when preparing the statement!");
        }

        return ticket;
    }

    // getting data, rather than inserting:
    @Override
    public Ticket getById(int id) {
        Logger logger = LoggerFactory.getLogger("Ticket Dao Impl");

        String sql = "select * from tickets where id = ?;";
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            //
            preparedStatement.setInt(1, id);
            System.out.println(preparedStatement);
            // Now that we've prepared the statement, we just want to execute it:
            // Result set is going to store the return value of the query:
            ResultSet resultSet = preparedStatement.executeQuery();

            // make sure we actually got a value from the query:
            if (resultSet.next()) {
                // parse out and extract the data
                int idDb = resultSet.getInt("id");
                int owner_id = resultSet.getInt("owner_id");
                String name = resultSet.getString("name");
                String description = resultSet.getString("description");
                int amount = resultSet.getInt("amount");
                boolean status = resultSet.getBoolean("status");

                // use the data to create a pet object

                return new Ticket(idDb, owner_id, name, amount, description, status);
                // return the pet object

            } else {
                System.out.println("something went wrong when trying to query for the pet, pet might not exist");
            }
        } catch (SQLException e) {
            System.out.println("Something went wrong when trying to retrieve data.");
            e.printStackTrace();

        }
        // if we reach the end of this method, return null
        return null;


    }
        @Override
        public Ticket getTicketStatus(int id) {
            String sql = "select * from tickets where id = ?;";
            try {
                PreparedStatement preparedStatement = connection.prepareStatement(sql);
                //
                preparedStatement.setInt(1, id);
                System.out.println(preparedStatement);
                // Now that we've prepared the statement, we just want to execute it:
                // Result set is going to store the return value of the query:
                ResultSet resultSet = preparedStatement.executeQuery();

                // make sure we actually got a value from the query:
                if(resultSet.next()) {
                    // parse out and extract the data
                    int idDb = resultSet.getInt("id");
                    int owner_id = resultSet.getInt("owner_id");
                    String name = resultSet.getString("name");
                    String description = resultSet.getString("description");
                    int amount = resultSet.getInt("amount");
                    boolean status =resultSet.getBoolean("status");

                    // use the data to create a pet object
                    return new Ticket(idDb, owner_id , name, amount, description , status);
                    // return the pet object
                }
                else {
                    System.out.println("something went wrong when trying to query for the pet, pet might not exist");
                }
            } catch (SQLException e) {
                System.out.println("Something went wrong when trying to retrieve data.");
                e.printStackTrace();

            }
            // if we reach the end of this method, return null
            return null;



        }
        /**
         * if(username already taken)
         * try {
         * throw new RegisterException
         * }
         * catch RegisterException{
         * print stackTrace
         */


    @Override
    public List<Ticket> getAllTickets() {
        // set up a list to store the return values (pets)
        List<Ticket> tickets = new ArrayList<>();

        // no actual parameter values here
        String sql = "select * from tickets;";
        try {
            // Use a simple statement here, because we don't have to change any parameters:
            Statement statement= connection.createStatement();

            ResultSet resultSet = statement.executeQuery(sql);

            // As opposed to :
            // PreparedStatement preparedStatement = connection.prepareStatement(sql);
            // statement.executeQuery()

            // now we're getting multiple pets so we use the while loop
            // we use a while loop that keeps incrementing the result set until we reach the end (null)
            while(resultSet.next()) {
                // for the current row, extract the data
                int id = resultSet.getInt("id");
                int owner_id = resultSet.getInt("owner_id");
                String name = resultSet.getString("name");
                String description = resultSet.getString("description");
                int amount = resultSet.getInt("amount");
                boolean status = resultSet.getBoolean("status");

                Ticket ticket = new Ticket(id, owner_id , name, amount, description , status);

                // add the current pet to the list of pets that we're returning:
                tickets.add(ticket);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        // at the very end, return pets:
        return tickets;
    }

    // For update, we take in some information and update a pre-existing record in the table:
    @Override
    public Ticket update(Ticket ticket) {
        String sql = "update tickets set description=?, status=?, processed=? where id = ?;";
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            preparedStatement.setString(1, ticket.getDescription());
            preparedStatement.setBoolean(2, ticket.getStatus());
            preparedStatement.setBoolean(3, ticket.getProcessed());
            preparedStatement.setInt(4, ticket.getId());

            int count = preparedStatement.executeUpdate(); // DML, we use executeUpdate instead of executeQuery
            preparedStatement.executeUpdate();
            if(count == 1) {
                System.out.println("Update successful!");
                return ticket;
            } //"update tickets set owner_id = ?, name = ?, description = ?, amount = ?, status= ? where id = ?;";
            else {
                System.out.println("Something went wrong with the update");
                if(count == 0) {
                    System.out.println("No rows were affected");
                }
                else {
                    System.out.println("Many rows were affected");
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }
        // return null
        return ticket;
    }
    @Override
    public Ticket updateTicketStatus(Ticket ticket) {
        String sql = "update tickets set status= ?, where id = ?;";
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            preparedStatement.setBoolean(1, ticket.getStatus());

            int count = preparedStatement.executeUpdate(); // DML, we use executeUpdate instead of executeQuery

            if(count == 1) {
                System.out.println("Update successful!");
                return ticket;
            }
            else {
                System.out.println("Something went wrong with the update");
                if(count == 0) {
                    System.out.println("No rows were affected");
                }
                else {
                    System.out.println("Many rows were affected");
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }
        // return null
        return null;
    }

    // only update a certain field/column:
//    public Pet updateFood(int id, String food) {
//        String sql = "update pet set food = ? where id = ?;";
//        PreparedStatement preparedStatement = connection.prepareStatement();
//        preparedStatement.setString(food);
//        preparedStatement.setInt(2, id);
//
//    }

    // return a boolean of whether the deletion was successful:
    @Override
    public boolean delete(int id) {
        String sql = "delete from tickets where id = ?;";
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1, id);

            int count = preparedStatement.executeUpdate();
            if(count == 1) {
                System.out.println("Deletion successful!");
                return true;
            }
            else {
                return false;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    //
    @Override
    public boolean assign(int employeeId, int ticketId) {
        // TODO check if id is null
        // important_________________________________________________________________________________________
        String sql = "update tickets set owner_id = ? where id = ?;";
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1, employeeId);
            preparedStatement.setInt(2, ticketId);
            int count = preparedStatement.executeUpdate();
            // if we've successfully update the table, we can return true
            if(count == 1) return true;
        } catch(SQLException e) {
            e.printStackTrace();
        }
        // for failure situations, we return false
        return false;
    }

    // given an owner id, return a list of pets that they've adopted
    @Override
    public List<Ticket> getAssignedTickets(int employeeId) {
        String sql = "select * from tickets where id = ?;";
        List<Ticket> pets = new ArrayList<>();
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1, employeeId);
            ResultSet resultSet = preparedStatement.executeQuery();


            while(resultSet.next()) {
                // for the current row, extract the data
                int id = resultSet.getInt("id");
                int owner_id = resultSet.getInt("owner_id");
                String name = resultSet.getString("name");
                String description = resultSet.getString("description");
                int amount = resultSet.getInt("amount");
                boolean status =resultSet.getBoolean("status");
                Ticket ticket = new Ticket(id,owner_id,  name, amount, description , status);

                // add the current pet to the list of pets that we're returning:
                pets.add(ticket);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return pets;
    }

    @Override
    public List<Ticket> getTicketsByPending( String descriptionz) {
    List<Ticket> tickets = new ArrayList<>();

    String sql = "select * from tickets where description=?;";
    try {
        PreparedStatement preparedStatement = connection.prepareStatement(sql);
        preparedStatement.setString(1, descriptionz);

        System.out.println(preparedStatement);
        ResultSet resultSet = preparedStatement.executeQuery();

        while (resultSet.next())
        {
            

            int idDb = resultSet.getInt("id");
            int owner_id = resultSet.getInt("owner_id");
            String name = resultSet.getString("name");
            boolean status= resultSet.getBoolean("status");
            boolean processed =resultSet.getBoolean("processed");
            String description= resultSet.getString("description");
            int amount = resultSet.getInt("amount");
            Ticket ticket= new Ticket(idDb, name, amount, description, status);
            tickets.add(ticket);

        }

    } catch (SQLException e) {
        throw new RuntimeException(e);
    }

        return tickets;
    }

    // CRUD Methods:


}
